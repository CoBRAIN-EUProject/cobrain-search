<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title align-items:center;>CoBRAIN Alloys — Interactive Chart with Filters & Details</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 18px; background-color: #EDEDED; color: #643554;}
    h2 { margin-bottom: 8px; color: #643554;}
    #controls { margin-bottom: 10px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    label { font-size:14px; }
    select, button { padding:6px 8px; font-size:14px; }
    #filters, #phaseFilter { margin-top:10px; margin-bottom:10px; }
    .slider-group { display:flex; align-items:center; margin:4px 0; gap:6px; }
    .slider-group label { width:40px; text-align:right; }
    input[type=range] { width:140px; }
    .checkbox-grid { display:grid; grid-template-columns:repeat(auto-fill, minmax(140px,1fr)); gap:4px; }
    .note { color:#666; font-size:13px; margin-top:6px; }
    #plot { width:100%; height:70vh; }
    /*new entry*/
    #controls, fieldset, #detailContainer {
    background-color: #FFFFFF;  /* white background for panels */
    border-radius: 8px;
    padding: 12px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }

button, select, input[type=range] {
    background-color: #E24B07;
    color: #FFFFFF;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    }

button:hover {
    background-color: #643554;
    } /*till here*/

    /* Detail panel */
    #detailContainer {
      margin-top: 24px;
      border-top: 1px solid #ccc;
      padding-top: 12px;
    }
    #detailHeader {
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
      margin-bottom:8px;
    }
    #detailContent {
      margin-top: 8px;
    }
    .detail-row {
      display:flex;
      flex-wrap:wrap;
      gap:24px;
    }
    .detail-block {
      min-width:220px;
      max-width:360px;
    }
    .detail-block h4 {
      margin: 4px 0 6px;
    }
    table.detail-table {
      border-collapse: collapse;
      width:100%;
      font-size:13px;
    }
    table.detail-table th,
    table.detail-table td {
      border:1px solid #ddd;
      padding:4px 6px;
      text-align:right;
    }
    table.detail-table th:first-child,
    table.detail-table td:first-child {
      text-align:left;
    }
    #compPie, #phasePie {
      width:360px;
      height:300px;
    }
  </style>
</head>
<body>
  <!--Header-->
  <header style="display:flex; align-items:center; gap:12px; margin-bottom:20px; background-color:#643554; padding:30px; border-radius:8px;">
    <!-- Column 1: Image -->
    <img src="https://www.cobrain-project.eu/wp-content/uploads/2023/07/CoBRAIN-LOGO-purple-small.png" alt="CoBRAIN Logo" style="height:80px; width:auto;">
    <!-- Column 2: Text -->
    <h2 style="margin:10; color:#ffffff;" style="font-size:32pt;">INTEGRATED COMPUTATIONAL / EXPERIMENTAL MATERIAL ENGINEERING OF THERMAL SPRAY COATINGS</h2>
  </header>
  <!--End of header-->
  <h2>CoBRAIN Alloys — Interactive Scatter with Filters</h2>
  <div id="elementCombos" style="margin:10px 0; font-size:14px;"></div>

  <div id="controls">
    <label>
      X-axis:
      <select id="xSelect">
        <option value="Hardness" selected>Hardness (HV)</option>
        <option value="PittingPotential">Pitting Potential (mV)</option>
        <option value="SFE">Stacking Fault Energy (mJ/m²)</option>
        <option value="WearRate">Wear rate (m3/mN)</option>
        <option value="Density">Density (kg/L)</option>
      </select>
    </label>
    <label>
      Y-axis:
      <select id="ySelect">
        <option value="SFE" selected>Stacking Fault Energy (mJ/m²)</option>
        <option value="Hardness">Hardness (HV)</option>
        <option value="PittingPotential">Pitting Potential (mV)</option>
        <option value="WearRate">Wear rate (m3/mN)</option>
        <option value="Density">Density (kg/L)</option>
      </select>
    </label>
    <label>
      Size by:
      <select id="sizeSelect">
        <option value="none">None</option>
        <option value="Hardness">Hardness</option>
        <option value="PittingPotential">PittingPotential</option>
        <option value="SFE">SFE</option>
        <option value="WearRate">Wear</option>
        <option value="Density">Density</option>
      </select>
    </label>
    <button id="refreshBtn">Refresh / Recompute</button>
  </div>

  <!-- Element sliders -->
  <fieldset id="filters">
    <legend><b>Element Filters (atomic %)</b></legend>
    <div id="sliderContainer"></div>
  </fieldset>

  <!-- Phase checkboxes -->
  <fieldset id="phaseFilter">
    <legend><b>Phase Filter</b></legend>
    <button id="togglePhasesBtn" type="button" style="margin-bottom:6px;">Deselect All</button>
    <div id="phaseContainer" class="checkbox-grid"></div>
  </fieldset>

  <div id="plot"></div>
  <div class="note">
    Hover points to see composition and phases.<br>
    Use sliders to limit element ranges (default 0–40 at%) and checkboxes to toggle visible phases.<br>
    Click a point or use the dropdown below to see full details.
  </div>

  <!-- Detail panel for a selected alloy -->
  <div id="detailContainer">
    <div id="detailHeader">
      <h3 style="margin:0;">Selected Alloy Details</h3>
      <label>
        Alloy:
        <select id="alloySelect">
          <option value="">— none selected —</option>
        </select>
      </label>
      <button id="openDatasheetBtn" type="button" onclick="location.href='datasheet.html'">
        Open datasheet
      </button>
      <span id="selectedAlloyLabel" style="font-size:14px; color:#555;"></span>
    </div>

    <div id="detailContent" style="display:none;">
      <div class="detail-row">
        <div class="detail-block">
          <h4>Composition</h4>
          <div id="compTable"></div>
        </div>
        <div class="detail-block">
          <h4>Properties</h4>
          <div id="propTable"></div>
        </div>
      </div>
      <div class="detail-row" style="margin-top:16px;">
        <div class="detail-block">
          <h4>Composition (at% — Pie)</h4>
          <div id="compPie"></div>
        </div>
        <div class="detail-block">
          <h4>Phases (vol. % — Pie)</h4>
          <div id="phasePie"></div>
        </div>
      </div>
    </div>
  </div>

<script>
const atomicMasses = { Al:26.982, Cr:51.996, Cu:63.546, Fe:55.845, Mn:54.95, Mo:95.94, Ni:58.693, Si:28.086 };
const elementDensities = { Al:2.7, Cr:7.19, Cu:8.96, Fe:7.86, Mn:54.94, Mo:10.2, Ni:8.9, Si:2.33 };
const filterElements = ["Al","Cr","Cu","Fe","Mn","Mo","Ni","Si"];

function safeGet(obj, path, def=undefined){
  try{
    let cur=obj;
    for(const p of path){
      cur = cur?.[p];
      if(cur===undefined) return def;
    }
    return cur;
  }catch(e){return def;}
}
function round2(x){ return (typeof x === 'number' && isFinite(x)) ? Math.round(x*100)/100 : null; }

/* --- scoring helpers --- */
let distThresholds = {
  hardness: null,
  pitting: null,
  sfe: null,
  wear: null,
  phase: null
};

function computePercentiles(arr) {
  if (!arr.length) return null;
  const sorted = [...arr].sort((a, b) => a - b);
  const n = sorted.length;
  const pct = (p) => {
    if (n === 1) return sorted[0];
    const idx = Math.floor((p / 100) * (n - 1));
    return sorted[idx];
  };
  return {
    p10: pct(10),
    p20: pct(20),
    p50: pct(50),
    p80: pct(80),
    p90: pct(90)
  };
}

function distanceToStars(dist, thresholds) {
  if (dist == null || !thresholds) return null;
  const { p10, p20, p50, p80, p90 } = thresholds;
  if (dist <= p10) return 5;
  if (dist <= p20) return 4;
  if (dist <= p50) return 3;
  if (dist <= p80) return 2;
  if (dist <= p90) return 1;
  return 1;
}

function starsToHtml(stars) {
  if (!stars) return '—';
  return '★'.repeat(stars) + '☆'.repeat(5 - stars);
}

let allRecords = [];
let allPhases = [];

/* === Load data and initialise === */
async function loadAndPlot(){
  const files = [
    'part_1.json',
    'part_2.json',
    'part_3.json',
    'part_4.json',
    'part_5.json',
    'part_6.json'
  ];

  let data = {};

  for (const file of files) {
    const resp = await fetch(file);
    const chunk = await resp.json();
    data = { ...data, ...chunk };
  }

  const records = [];

  const hardnessDists = [];
  const pittingDists = [];
  const sfeDists = [];
  const wearDists = [];
  const phaseDists = [];

  // process one composition inside a family
  function processComposition(familyName, compName, props) {
    if (!props || typeof props !== 'object') return;

    const hardnessBlock = props.hardness && typeof props.hardness === 'object'
      ? props.hardness
      : {};

    // atomic composition (from hardness block)
    const at = {};
    for (const [k, v] of Object.entries(hardnessBlock)) {
      if (filterElements.includes(k) && typeof v === 'number') {
        at[k] = v;
      }
    }
    if (Object.keys(at).length === 0) return;

    // weight fractions
    const totalMass = Object.entries(at)
      .reduce((s, [el, v]) => s + (v * atomicMasses[el]), 0);
    const wt = {};
    if (totalMass > 0) {
      for (const [el, v] of Object.entries(at)) {
        wt[el] = (v * atomicMasses[el]) / totalMass * 100;
      }
    }

    // density via simple rule of mixtures
    let density = null;
    if (Object.keys(wt).length &&
        Object.keys(wt).every(el => elementDensities[el])) {
      const denom = Object.entries(wt)
        .reduce((s, [el, v]) => s + (v/100)/elementDensities[el], 0);
      density = 1/denom;
    }

    // phases: props.phase.phase = {phaseName: fraction}
    let phaseMap = {};
    if (props.phase && typeof props.phase === 'object') {
      if (props.phase.phase && typeof props.phase.phase === 'object') {
        phaseMap = props.phase.phase;
      } else {
        phaseMap = props.phase; // just in case
      }
    }

    const phaseEntries = Object.entries(phaseMap)
      .filter(([, v]) => typeof v === 'number')
      .sort((a, b) => b[1] - a[1]);

    const phasesFull = phaseEntries.map(([n, v]) => ({
      name: n,
      val: v * 100
    }));
    const topPhases = phasesFull.slice(0, 3);

    // distances
    const hardDist  = safeGet(props, ["hardness", "Distance"]);
    const pitDist   = safeGet(props, ["pitting_potential", "Distance"]);
    const sfeDist   = safeGet(props, ["stacking_fault_energy", "Distance"]);
    const wearDist  = safeGet(props, ["wear_rate", "Distance"]);
    const phaseDist = safeGet(props, ["phase", "distance"]);

    if (typeof hardDist === 'number')  hardnessDists.push(hardDist);
    if (typeof pitDist === 'number')   pittingDists.push(pitDist);
    if (typeof sfeDist === 'number')   sfeDists.push(sfeDist);
    if (typeof wearDist === 'number')  wearDists.push(wearDist);
    if (typeof phaseDist === 'number') phaseDists.push(phaseDist);

    records.push({
      Family: familyName,
      Alloy: compName,          // composition name (used everywhere)
      at,
      wt,
      Hardness: safeGet(props,["hardness","Hardness"]),
      PittingPotential: safeGet(props,["pitting_potential","PittingPotential"]),
      SFE: safeGet(props,["stacking_fault_energy","StackingFaultEnergy"]),
      Wear: safeGet(props,["wear_rate","WearRate"]),
      Density: density ? round2(density) : null,
      Phases: phasesFull,
      TopPhases: topPhases,
      HardnessDist: hardDist,
      PittingDist: pitDist,
      SFEDist: sfeDist,
      WearDist: wearDist,
      PhaseDist: phaseDist
    });
  }

  // NEW: strictly follow the family → compositions schema
  for (const [familyName, compositions] of Object.entries(data)) {
    if (!compositions || typeof compositions !== 'object') continue;
    for (const [compName, props] of Object.entries(compositions)) {
      processComposition(familyName, compName, props);
    }
  }

  // Compute thresholds for stars
  distThresholds = {
    hardness: computePercentiles(hardnessDists),
    pitting:  computePercentiles(pittingDists),
    sfe:      computePercentiles(sfeDists),
    wear:     computePercentiles(wearDists),
    phase:    computePercentiles(phaseDists)
  };

  // Distinct 5-element combos = top-level family names
  const families = Object.keys(data).sort();
  const comboDiv = document.getElementById('elementCombos');

  const prettyFamilies = families.map(fam => {
    // split "AlCrCuFeMo" → ["Al","Cr","Cu","Fe","Mo"]
    const els = fam.match(/[A-Z][a-z]?/g) || [fam];
    return els.join('-');
  });

  comboDiv.innerHTML =
    `<b>Distinct 5-element groups (families):</b> (${families.length})<br>` +
    prettyFamilies.join('<br>');

  allRecords = records;
  setupSliders();
  setupPhaseFilter(records);
  populateAlloySelect();
  drawPlot();
}


/* === Sliders === */
function setupSliders(){
  const container=document.getElementById('sliderContainer');
  container.innerHTML='';
  for(const el of filterElements){
    const div=document.createElement('div');
    div.className='slider-group';
    div.innerHTML=`
      <label>${el}</label>
      <input type="range" id="${el}Min" min="0" max="100" value="0" step="0.5">
      <span id="${el}MinVal">0</span>
      <span>–</span>
      <input type="range" id="${el}Max" min="0" max="100" value="40" step="0.5">
      <span id="${el}MaxVal">40</span>`;
    container.appendChild(div);
    const minEl=document.getElementById(`${el}Min`);
    const maxEl=document.getElementById(`${el}Max`);
    minEl.oninput=()=>{document.getElementById(`${el}MinVal`).textContent=minEl.value; drawPlot();}
    maxEl.oninput=()=>{document.getElementById(`${el}MaxVal`).textContent=maxEl.value; drawPlot();}
  }
}

/* === Phase checkboxes === */
function setupPhaseFilter(records){
  const container=document.getElementById('phaseContainer');
  container.innerHTML='';
  const phaseSet=new Set();
  records.forEach(r=>r.TopPhases?.forEach(p=>phaseSet.add(p.name)));
  allPhases = Array.from(phaseSet).sort();
  for(const ph of allPhases){
    const id=`phase_${ph}`;
    const div=document.createElement('div');

    const isPreferred =
      ph.toUpperCase().includes('BCC') ||
      ph.toUpperCase().includes('FCC');

    div.innerHTML=`<label><input type="checkbox" id="${id}" ${isPreferred ? 'checked' : ''}> ${ph}</label>`;
    container.appendChild(div);
    document.getElementById(id).onchange=drawPlot;
  }
  const btn = document.getElementById('togglePhasesBtn');
  if (btn) btn.textContent = 'Select All';
}

/* === Toggle all phase checkboxes === */
function toggleAllPhases(){
  const btn = document.getElementById('togglePhasesBtn');
  const checkboxes = allPhases.map(ph => document.getElementById(`phase_${ph}`));
  const allChecked = checkboxes.every(ch => ch.checked);
  for (const ch of checkboxes) ch.checked = !allChecked;
  btn.textContent = allChecked ? "Select All" : "Deselect All";
  drawPlot();
}

/* === Filtering for plot === */
function applyFilters(records){
  return records.filter(r=>{
    const inRange = filterElements.every(el=>{
      const val=(r.at?.[el]||0)*100;
      const minv=parseFloat(document.getElementById(`${el}Min`).value);
      const maxv=parseFloat(document.getElementById(`${el}Max`).value);
      return val>=minv && val<=maxv;
    });
    if(!inRange) return false;
    const firstPhase=r.TopPhases?.[0]?.name || 'Unknown';
    const visible=document.getElementById(`phase_${firstPhase}`);
    return !visible || visible.checked;
  });
}

/* === Plot === */
function drawPlot() {
  const xSel = document.getElementById('xSelect').value;
  const ySel = document.getElementById('ySelect').value;
  const sizeSel = document.getElementById('sizeSelect').value;
  const filtered = applyFilters(allRecords);

  const groups = {};
  for (const r of filtered) {
    const phase = r.TopPhases?.[0]?.name || 'Unknown';
    if (!groups[phase]) groups[phase] = [];
    groups[phase].push(r);
  }

  const traces = [];
  for (const [ph, recs] of Object.entries(groups)) {
    const xs = recs.map(r => r[xSel]);
    const ys = recs.map(r => r[ySel]);

    let sizes = recs.map(_ => 10);
    if (sizeSel !== 'none') {
      const vals = recs.map(r => r[sizeSel] || 0);
      const minv = Math.min(...vals);
      const maxv = Math.max(...vals);
      sizes = vals.map(v => 8 + 30 * ((v - minv) / (maxv - minv || 1)));
    }

    const hover = recs.map(r => {
      const atsList = Object.entries(r.at)
        .map(([e, v]) => `${e}: ${round2(v * 100)}%`)
        .join('<br>');
      const wtsList = Object.entries(r.wt)
        .map(([e, v]) => `${e}: ${round2(v)}%`)
        .join('<br>');
      const phases = r.TopPhases?.map(p => `${p.name} (${round2(p.val)}%)`).join('<br>') || '';

      return `
        <b>${r.Alloy}</b><br>
        X: ${r[xSel]}<br>
        Y: ${r[ySel]}<br>
        Wear: ${r.Wear != null ? round2(r.Wear) : 'n/a'}<br>
        <b>Composition (at%)</b><br>${atsList}<br>
        <b>Composition (wt%)</b><br>${wtsList}<br>
        <b>Density:</b> ${r.Density || 'n/a'}<br>
        <b>Phases (top 3):</b><br>${phases}
      `;
    });

    const customdata = recs.map(r => r.Alloy);

    traces.push({
      x: xs,
      y: ys,
      text: hover,
      customdata: customdata,
      hoverinfo: 'text',
      mode: 'markers',
      name: ph,
      marker: {
        size: sizes,
        opacity: 0.9,
        line: { width: 0.5, color: 'rgba(0,0,0,0.2)' }
      }
    });
  }

  const layout = {
    title: `Alloys (${filtered.length} shown)`,
    xaxis: { title: xSel },
    yaxis: { title: ySel },
    legend: { orientation: 'h', x: 0, y: -0.2 },
    hovermode: 'closest'
  };

  const config = { responsive: true };

  Plotly.newPlot('plot', traces, layout, config).then(gd => {
    gd.removeAllListeners('plotly_click');
    gd.on('plotly_click', function(ev) {
      const pt = ev.points && ev.points[0];
      if (!pt || pt.customdata == null) return;
      const alloyName = pt.customdata;
      const rec = allRecords.find(r => r.Alloy === alloyName);
      if (rec) {
        const selectEl = document.getElementById('alloySelect');
        if (selectEl) selectEl.value = alloyName;
        renderDetail(rec);
      }
    });
  });
}

/* === Alloy dropdown === */
function populateAlloySelect(){
  const sel = document.getElementById('alloySelect');
  while (sel.options.length > 1) sel.remove(1);
  const names = allRecords.map(r => r.Alloy).sort();
  for(const name of names){
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = name;
    sel.appendChild(opt);
  }
  sel.onchange = function(){
    const v = sel.value;
    const btn = document.getElementById('openDatasheetBtn');
    if(!v){
      document.getElementById('detailContent').style.display='none';
      document.getElementById('selectedAlloyLabel').textContent = '';
      if (btn) {
        btn.disabled = true;
        btn.onclick = null;
      }
      return;
    }
    const rec = allRecords.find(r => r.Alloy === v);
    if(rec) renderDetail(rec);
  };
}

/* === Render detail panel === */
function renderDetail(rec){
  if(!rec) return;

  const detailDiv = document.getElementById('detailContent');
  detailDiv.style.display = 'block';
  document.getElementById('selectedAlloyLabel').textContent =
    ` (showing: ${rec.Alloy})`;

  const btn = document.getElementById('openDatasheetBtn');
  if (btn) {
    btn.disabled = false;
    btn.onclick = () => {
      const url = 'datasheet.html?alloy=' + encodeURIComponent(rec.Alloy);
      window.open(url, '_blank');
    };
  }

  // --- Composition table ---
  const compDiv = document.getElementById('compTable');
  const elements = Object.keys(rec.at).sort();
  let compHtml = '<table class="detail-table"><thead><tr>' +
                 '<th>Element</th><th>at%</th><th>wt%</th></tr></thead><tbody>';
  for(const el of elements){
    const atp = round2(rec.at[el]*100);
    const wtp = round2(rec.wt[el]);
    compHtml += `<tr><td>${el}</td><td>${atp}</td><td>${wtp}</td></tr>`;
  }
  compHtml += '</tbody></table>';
  compDiv.innerHTML = compHtml;

  // --- Properties table with stars (incl. phase) ---
  const propDiv = document.getElementById('propTable');

  const starsHard  = distanceToStars(rec.HardnessDist, distThresholds.hardness);
  const starsPit   = distanceToStars(rec.PittingDist,  distThresholds.pitting);
  const starsSFE   = distanceToStars(rec.SFEDist,      distThresholds.sfe);
  const starsWear  = distanceToStars(rec.WearDist,     distThresholds.wear);
  const starsPhase = distanceToStars(rec.PhaseDist,    distThresholds.phase);

  const firstPhaseObj = rec.TopPhases && rec.TopPhases[0] ? rec.TopPhases[0] : null;
  const firstPhaseLabel = firstPhaseObj
    ? `${firstPhaseObj.name} (${round2(firstPhaseObj.val)}%)`
    : 'n/a';

  const props = [
    ['Hardness (HV)',                 rec.Hardness,         starsHard],
    ['Pitting potential (mV)',        rec.PittingPotential, starsPit],
    ['Stacking fault energy (mJ/m²)', rec.SFE,              starsSFE],
    ['Wear Rate (m3/mN)',               rec.Wear,             starsWear],
    ['First phase (vol. %)',          firstPhaseLabel,      starsPhase],
    ['Density (kg/L)',                rec.Density,          null]
  ];

  let propHtml = '<table class="detail-table"><thead><tr>' +
                 '<th>Property</th><th>Value</th><th>Score</th>' +
                 '</tr></thead><tbody>';

  for (const [label, val, stars] of props) {
    const formattedVal =
      typeof val === 'number' ? round2(val) :
      (val != null ? val : 'n/a');

    propHtml += `<tr>
      <th>${label}</th>
      <td>${formattedVal}</td>
      <td>${starsToHtml(stars)}</td>
    </tr>`;
  }
  propHtml += '</tbody></table>';
  propDiv.innerHTML = propHtml;

  // --- Composition pie (at%) ---
  const compLabels = elements;
  const compValues = elements.map(el => rec.at[el]*100);
  Plotly.newPlot('compPie', [{
    type: 'pie',
    labels: compLabels,
    values: compValues,
    textinfo: 'label+percent',
    hovertemplate: '%{label}: %{value:.2f}%<extra></extra>'
  }], {
    margin:{l:0,r:0,t:10,b:10}
  }, {responsive:true});

  // --- Phases pie ---
  const phases = (rec.Phases || []).filter(p => p.val > 0.01);
  if (phases.length > 0){
    const phaseLabels = phases.map(p => p.name);
    const phaseValues = phases.map(p => p.val);
    Plotly.newPlot('phasePie', [{
      type: 'pie',
      labels: phaseLabels,
      values: phaseValues,
      textinfo: 'label+percent',
      hovertemplate: '%{label}: %{value:.2f} %<extra></extra>'
    }], {
      margin:{l:0,r:0,t:10,b:10}
    }, {responsive:true});
  } else {
    document.getElementById('phasePie').innerHTML =
      '<div style="font-size:12px;color:#666;margin-top:40px;">No phase data available.</div>';
  }
}

/* === Bind top-level events === */
document.getElementById('refreshBtn').onclick = drawPlot;
document.getElementById('xSelect').onchange = drawPlot;
document.getElementById('ySelect').onchange = drawPlot;
document.getElementById('sizeSelect').onchange = drawPlot;
document.getElementById('togglePhasesBtn').onclick = toggleAllPhases;

/* === Start === */
loadAndPlot();
</script>
<footer style="margin-top:40px; padding:12px; background-color:#EDEDED; color:#643554;">
  <div style="display:inline-flex; align-items:center; gap:8px;">
    <img src="https://www.cobrain-project.eu/wp-content/uploads/2026/02/EU_logo.png" alt="EU_Logo" style="height:30px;">
    <span style="font-size:9pt !important;">Funded by the European Union under the GA no <b>101092211</b>. Views and opinions expressed are however those of the author(s) 
      only and do not necessarily reflect those of the European Union or HaDEA. Neither the European Union nor the granting authority 
      can be held responsible for the granting authority can be held responsible for them.</span>
    <span></span>
    <span style="font-size:9pt !important;"><b>© 2026 CoBRAIN Project</b> — All rights reserved</span>
  </div>
</footer>
</body>
</html>
